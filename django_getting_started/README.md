# Introduction

The basics basics of this was enspired by several courses, where the outcome and topics got condensed into this project. The documentation for Django can be found @ https://docs.djangoproject.com/en/3.1/

## Environment

Assuming you are familiar with Python basics, you have the source checked out and you understand the basics, Start this project using an IDE or using the command line run `python manage.py runserver` and that will output the applicationto http://localhost:8000

## Get started

- If you have the full version of Pycharm, start with the django template

- Creating a **new Python project** in *Pycharm* community then create an empty python project and then inititalising it with `python -m pip install django` 

  - `django-admin startproject  <ProjectName>` for creating a new project

- `python manage.py runserver` to run the project

- The full course can be found at [django_getting_started](https://github.com/codesensei-courses/django_getting_started)

- Create another folder `python manage.py startapp <folder or domain name>`

- `python manage.py showmigrations` shows migrations not yet set and `python manage.py migrate` migrates the changes

- `python manage.py dbshell` show **sqlite** db entries but it is easier through pycharm database console

- `python manage.py makemigrations` generates a migration based on the model created and needs this to be setup in the applications

- `python manage.py sqlmigrate <modelname> <version>` will migrate the sql generated from the migration

- ` python manage.py migrate` generates the migration into the database

- `python manage.py createsuperuser` to create an **admin** for the site which works on the http://localhost:8000/admin URL

- Django model fields and setting up the models can be found https://docs.djangoproject.com/en/3.1/ref/models/fields/

  ## Anatomy of a Django Project

- Using the meeting project as an example the root project can be found [django_getting_started](../django_getting_started)

- The project settings can be found under [meeting_planner](meeting_planner)

- [settings.py](meeting_planner/settings.py) is used for configuring apps, middleware, templates and database settings

- [urls.py](django_getting_started/meeting_planner/urls.py) is used for configuring the routes to the various application folders or application domains

  - [URL's](django_getting_started/meetings/urls.py) found in application domains represent the relative routes under the root URL e.g. meetings will utilise meetings.urls

    ```python
    urlpatterns = [
        path('admin/', admin.site.urls),
        path('', welcome, name="home"),
        path('aboutvincent', about, name="about"),
        path('meetings/', include('meetings.urls'))
    ]
    ```

  - URL's can change any time so if you reference the **url by name**, then the URL references can be autogenerated under the hood by a lookup so no need to change the specific URL (see [welcome.html](django_getting_started/website/templates/website/welcome.html) for more or referencing URL's) 

- [meetings](django_getting_started/meetings) represents a single domain under meeting planner and essentially you can have as many as desiredor as mapped to urls as logical bits of the rest API and possibly this can be seen as an extension of the Domain Driven Design

- The sub domain can be broken up into

  - **models**: create all models to link with views

    ```python
    class Room(models.Model):
        name = models.TextField(max_length=50)
        floor = models.IntegerField(default=1)
        room = models.TextField(max_length=50)
    
        def __str__(self):
            return f'{self.name} on floor {str(self.floor)} room {str(self.room)}'
    ```

  - **views**: create python functions

    ```python
    def detail(request, meeting_id):
        # meeting = Meeting.objects.get(pk=meeting_id)
        meeting = get_object_or_404(Meeting, pk=meeting_id)
        data = dict(meeting=meeting)
        return render(request, "meetings/detail.html", data)
    ```

  - **urls**: create relative routes

    ```python
    urlpatterns = [
        path('<int:meeting_id>', detail, name="detail"),
        path('rooms', rooms, name="rooms")
    ]
    ```

  - **admin**: register admin functionality around data

    ```python
    admin.site.register(Meeting)
    admin.site.register(Room)	
    ```

  - **templates**: create an html template with django templating language. The template folder must follow "templates/<domain>/<file.html>" and the reference to to the template should always be *domain*/<*file.html*>

    ```html
    <!-- rooms.html  -->
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>All Rooms</title>
    </head>
    <style>
        dl {
            display: block;
            margin: 1em 0;
        }
    </style>
    <body>
    <h2>All Rooms</h2>
    <div>
        <a href="{% url "home" %}">Back Home</a>
    </div>
    <dl>
        {% for room in rooms %}
            <dt>{{ room.name }}</dt>
            <dd>Floor {{ room.floor }}</dd>
            <dd>Room {{ room.room }}</dd>
        {% endfor %}
    </dl>
    </body>
    </html>
    ```

  - **Forms**: Allows for *metadata* exposure and extended *validation* to occur through the generated form logic. The meta defines how django can output html components with configured editor and the clean_date allows for a custom validator to be defined

    ```python
    class MeetingForm(ModelForm):
        class Meta:
            model = Meeting
            fields = '__all__'
            widgets = {
                'date': DateInput(attrs={"type": "date"}),
                'start_time': TimeInput(attrs={"type": "time"}),
                'duration': TextInput(attrs={"type": "number", "min": "15", "max": "1440"}),
            }
    
        def clean_date(self):
            date = self.cleaned_data.get("date")
            if date < date.today():
                raise ValidationError("Meetings cannot be in the past")
            return date
    ```

  - **apps**: Allow for configuration of the logical app or domain representation

  - **tests**: test with framework like **pytest** is a good fit for tests

  ## Base templating

- Django permits defining a base template or templates to share common ideas e.g.

  ```html
  {% load static %}
  <!DOCTYPE html>
  <html lang="en">
  <head>
      <meta charset="UTF-8">
      <title>{% block title %}{% endblock %}</title>
      <link rel="stylesheet" href="{% static 'website/style.css' %}">
      {% block head %}
      {% endblock %}
  </head>
  <body>
      {% block content %}
      {% endblock %}
  </body>
  <footer>
      {% block footer %}
      {% endblock %}
  </footer>
  </html>
  ```

- Referencing the content can be done through

  ```html
  <!-- details.html-->
  {% extends "base.html" %}
  
  {% block title %}
      Meeting: {{ meeting.title }}
  {% endblock %}
  
  {% block head %}
      <link rel="stylesheet" href="detail.css">
  {% endblock %}
  
  {% block content %}
      <details>
          <summary>{{ meeting.title }} details</summary>
          <dl>
              <dt><strong>Date: </strong>{{ meeting.date }}</dt>
              <dd><strong>Time: </strong>{{ meeting.start_time }}</dd>
              <dd><strong>Duration: </strong>{{ meeting.duration }} minutes</dd>
              <dt><strong>Room: </strong>{{ meeting.room }}</dt>
          </dl>
      </details>
  {% endblock %}
  
  {% block footer %}
      <div>
          <a href="{% url "home" %}">Back Home</a>
      </div>
  {% endblock %}
  ```

  ## Deployment

  **Heroku** is a good PAAS offering for deployin a django application for quick and cheap

- Create a **Heroku account**

- **Download CLI** at https://devcenter.heroku.com/ or install on a Mac `curl https://cli-assets.heroku.com/install.sh | sh` installed to */usr/local/bin/heroku* and login by typing `heroku login`

- Here is some more info on [getting started](https://devcenter.heroku.com/articles/getting-started-with-python) with python

- Create a **Procfile** in the root of your project

  ```python
  # Procfile
  web: gunicorn meeting_planner.wsgi
  ```

- `pip install gunicorn`

- `pip install django-heroku`

- `pip freeze > requirements.txt`

- At the bottom of the **settings.py** file add `django_heroku.settings(locals())` and import django_heroku

- Create a deployment by `heroku create django-meeting-planner-app --buildpack heroku/python` which installs to https://git.heroku.com/django-meeting-planner-app.git

- Navigate to https://dashboard.heroku.com/apps to see deployed app to https://dashboard.heroku.com/apps/django-meeting-planner-app

- check `https://git.heroku.com/django-meeting-planner-app.git`

- check `git remotes -v` to make sure heroku is setup 

- **NOTE**: Unable to deploy as I did not have this project setup in the root as it is expected - move this to the root and this should start working as expected

  ## Testing

  TODO

  ## References

- **All documentation** can be found at https://docs.djangoproject.com/en/3.1/

- **Template** documentation can be found at https://docs.djangoproject.com/en/3.1/ref/templates/language/#templates

- 

  

  # Summary

  Finally when everything is generated, run `pip freeze > requirements.txt` to generate all the dependencies used in the project so other inheriting the project can generate the correct virtual environment

